# LanLink 执行逻辑详解

## 📖 目录

1. [程序启动流程](#程序启动流程)
2. [核心模块交互](#核心模块交互)
3. [心跳机制](#心跳机制)
4. [节点发现流程](#节点发现流程)
5. [离线检测机制](#离线检测机制)
6. [Hosts文件更新](#hosts文件更新)
7. [优雅退出](#优雅退出)

---

## 程序启动流程

### 步骤详解

```
┌─────────────────────────────────────────────────┐
│  第1步: 加载配置                                 │
│  - 读取 config.json (如果存在)                   │
│  - 否则使用默认配置                               │
│  - 自动获取主机名作为设备名                       │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│  第2步: 初始化日志系统                            │
│  - 创建日志文件 lanlink.log                      │
│  - 设置日志级别 (debug/info/warn/error)          │
│  - 同时输出到控制台和文件                         │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│  第3步: 检查权限                                  │
│  - 尝试打开 Hosts 文件 (读写模式)                 │
│  - Windows: C:\Windows\System32\drivers\etc\hosts│
│  - Linux/Mac: /etc/hosts                         │
│  - 如果失败，提示需要管理员权限并退出              │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│  第4步: 初始化 Hosts 文件                         │
│  - 检查是否已有 LanLink 标记区域                  │
│  - 如果没有，在文件末尾添加:                      │
│    # === LanLink Managed Begin ===              │
│    # === LanLink Managed End ===                │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│  第5步: 获取本机信息                              │
│  - MAC地址: 作为唯一设备ID                        │
│  - IP地址: 自动获取第一个非回环的IPv4地址         │
│  - 主机名: 从配置或系统获取                       │
│  - 域名: 生成 {deviceName}.{suffix}              │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│  第6步: 创建组播客户端                            │
│  - 创建UDP套接字                                  │
│  - 绑定到所有接口的指定端口 (默认9527)            │
│  - 加入组播组 (默认239.255.0.1)                   │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│  第7步: 创建节点管理器                            │
│  - 初始化节点列表 (空的map)                       │
│  - 添加本机节点到列表                             │
│  - 标记本机节点 (IsLocal = true)                 │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│  第8步: 设置回调函数                              │
│  - 节点变化回调 → 更新 Hosts 文件                │
│  - 消息接收回调 → 处理心跳和离线消息              │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│  第9步: 启动组播监听                              │
│  - 启动后台goroutine接收组播消息                  │
│  - 过滤自己发送的消息 (通过IP判断)                │
│  - 收到消息后调用回调函数                         │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│  第10步: 发送首次心跳                             │
│  - 立即广播自己的信息                             │
│  - 让局域网内其他节点立即发现本机                 │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│  第11步: 进入主循环                               │
│  - 启动定时心跳 (每10秒)                         │
│  - 启动定时离线检测 (每5秒)                      │
│  - 监听退出信号 (Ctrl+C)                         │
└─────────────────────────────────────────────────┘
```

---

## 核心模块交互

### 模块关系图

```
┌──────────────────────────────────────────────────────┐
│                     Main (协调层)                     │
│  - 初始化所有模块                                     │
│  - 设置回调关系                                       │
│  - 管理程序生命周期                                   │
└──────────────────────────────────────────────────────┘
         │                │                │
         ├────────────────┼────────────────┤
         ↓                ↓                ↓
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│   Config    │  │   Logger    │  │   Network   │
│  配置管理    │  │  日志记录    │  │  组播通信    │
└─────────────┘  └─────────────┘  └─────────────┘
                                         │
                                         │ (接收消息)
                                         ↓
                                  ┌─────────────┐
                                  │    Node     │
                                  │  节点管理    │
                                  └─────────────┘
                                         │
                                         │ (节点变化回调)
                                         ↓
                                  ┌─────────────┐
                                  │    Hosts    │
                                  │ Hosts管理   │
                                  └─────────────┘
                                         │
                                         ↓
                                  ┌─────────────┐
                                  │ Hosts File  │
                                  │  系统文件    │
                                  └─────────────┘
```

### 回调机制

LanLink 使用 **事件驱动** 的设计模式：

```go
// 回调1: 节点变化 → 更新 Hosts
nodeManager.SetChangeCallback(func(n *node.Node, isOnline bool) {
    if isOnline {
        // 节点上线 → 添加到 Hosts
        hostsManager.AddOrUpdate(n.IP, n.Domain)
    } else {
        // 节点离线 → 从 Hosts 删除
        hostsManager.Remove(n.Domain)
    }
})

// 回调2: 收到消息 → 更新节点
client.SetMessageCallback(func(msg *network.Message) {
    if msg.Action == "heartbeat" {
        // 收到心跳 → 更新节点信息
        nodeManager.AddOrUpdate(...)
    } else if msg.Action == "offline" {
        // 收到离线通知 → 删除节点
        nodeManager.Remove(...)
    }
})
```

**为什么用回调？**
- ✅ 解耦模块：各模块不直接依赖
- ✅ 响应式：事件发生时自动触发
- ✅ 灵活：易于扩展和修改

---

## 心跳机制

### 心跳消息结构

```json
{
  "action": "heartbeat",
  "domain": "mypc.local",
  "ip": "192.168.1.100",
  "deviceId": "mac-00:11:22:33:44:55",
  "hostname": "MYPC",
  "timestamp": 1732694400
}
```

### 心跳发送流程

```
                主循环
                  │
                  ↓
          ┌───────────────┐
          │ 定时器触发     │ ← 每10秒
          │ (Ticker)      │
          └───────────────┘
                  │
                  ↓
          ┌───────────────┐
          │ 构造心跳消息   │
          │ - action      │
          │ - domain      │
          │ - ip          │
          │ - deviceId    │
          │ - hostname    │
          │ - timestamp   │
          └───────────────┘
                  │
                  ↓
          ┌───────────────┐
          │ JSON序列化     │
          └───────────────┘
                  │
                  ↓
          ┌───────────────┐
          │ UDP组播发送    │ → 239.255.0.1:9527
          └───────────────┘
                  │
                  ↓
        局域网内所有节点接收
```

### 心跳接收流程

```
     组播接收 (后台goroutine)
              │
              ↓
      ┌───────────────┐
      │ 收到UDP数据包  │
      └───────────────┘
              │
              ↓
      ┌───────────────┐
      │ 过滤自己的消息 │ ← 通过IP判断
      │ if msg.IP ==   │
      │   localIP      │
      │   → 忽略       │
      └───────────────┘
              │
              ↓
      ┌───────────────┐
      │ JSON反序列化   │
      └───────────────┘
              │
              ↓
      ┌───────────────┐
      │ 调用消息回调   │
      └───────────────┘
              │
              ↓
      ┌───────────────┐
      │ 检查消息类型   │
      └───────────────┘
              │
      ┌───────┴───────┐
      ↓               ↓
[heartbeat]     [offline]
      │               │
      ↓               ↓
  更新节点         删除节点
```

---

## 节点发现流程

### 场景：设备A 发现 设备B

```
┌─────────────┐                        ┌─────────────┐
│   设备 A    │                        │   设备 B    │
│ 192.168.1.100                        │ 192.168.1.101
│ pc-a.local  │                        │ pc-b.local  │
└─────────────┘                        └─────────────┘
      │                                       │
      │ 1. A启动，发送首次心跳                │
      ├───────────────────────────────────────>
      │   {"action":"heartbeat",              │
      │    "domain":"pc-a.local",             │
      │    "ip":"192.168.1.100"...}           │
      │                                       │
      │                 2. B启动，发送首次心跳 │
      <───────────────────────────────────────┤
      │                {"action":"heartbeat", │
      │                 "domain":"pc-b.local",│
      │                 "ip":"192.168.1.101"..}
      │                                       │
      │ 3. A收到B的心跳                       │
      │    → 添加B到节点列表                  │
      │    → 触发节点变化回调                 │
      │    → 更新Hosts文件:                   │
      │       192.168.1.101  pc-b.local       │
      │                                       │
      │                 4. B收到A的心跳        │
      │                    → 添加A到节点列表   │
      │                    → 更新Hosts文件:    │
      │                    192.168.1.100 pc-a.local
      │                                       │
      │ 5. A 可以 ping pc-b.local ✓           │
      │                 6. B 可以 ping pc-a.local ✓
      │                                       │
```

### 代码实现逻辑

```go
// 收到心跳消息
func onMessageReceived(msg *Message) {
    // 1. 检查是否是新节点
    _, exists := nodeManager.Get(msg.DeviceID)
    
    // 2. 检查域名冲突
    if !exists && hasDomainConflict(msg.Domain, msg.DeviceID) {
        // 自动重命名: pc-a.local → pc-a-aabbcc.local
        msg.Domain = msg.Domain + "-" + extractMACShort(msg.DeviceID)
    }
    
    // 3. 添加或更新节点
    changed := nodeManager.AddOrUpdate(
        msg.DeviceID, 
        msg.Domain, 
        msg.IP, 
        msg.Hostname
    )
    
    // 4. 如果节点信息有变化，触发回调
    if changed {
        // → 自动更新 Hosts 文件
    }
}
```

---

## 离线检测机制

### 检测原理

每个节点维护 `LastSeen` 时间戳，记录最后一次收到心跳的时间。

```go
type Node struct {
    DeviceID  string
    Domain    string
    IP        string
    Hostname  string
    LastSeen  time.Time  // 关键字段
    IsLocal   bool
}
```

### 检测流程

```
        主循环
          │
          ↓
  ┌───────────────┐
  │ 定时器触发     │ ← 每5秒
  │ (Ticker)      │
  └───────────────┘
          │
          ↓
  ┌───────────────┐
  │ 遍历所有节点   │
  └───────────────┘
          │
          ↓
  ┌───────────────────────────┐
  │ 计算时间差                 │
  │ now - node.LastSeen        │
  └───────────────────────────┘
          │
          ↓
  ┌───────────────────────────┐
  │ 是否超过30秒？             │
  └───────────────────────────┘
          │
    ┌─────┴─────┐
    ↓           ↓
  [是]         [否]
    │           │
    ↓           ↓
 标记离线     继续监控
    │
    ↓
删除节点
    │
    ↓
触发回调
    │
    ↓
删除Hosts条目
```

### 代码实现

```go
func (m *Manager) CheckOffline() []*Node {
    now := time.Now()
    offlineNodes := make([]*Node, 0)
    
    for deviceID, node := range m.nodes {
        // 跳过本机
        if node.IsLocal {
            continue
        }
        
        // 检查超时
        if now.Sub(node.LastSeen) > m.offlineTimeout {
            offlineNodes = append(offlineNodes, node)
            delete(m.nodes, deviceID)
            
            // 触发离线回调
            if m.onNodeChange != nil {
                m.onNodeChange(node, false)
            }
        }
    }
    
    return offlineNodes
}
```

### 时间轴示例

```
时间 →
0s    10s   20s   30s   35s
│     │     │     │     │
├─────┼─────┼─────┼─────┤
│     │     │     │     │
心跳1  心跳2  心跳3  ⚠️    ❌ 离线
                 (最后心跳)  (超过30秒)

正常情况：每10秒一次心跳
异常情况：30秒未收到 → 判定离线
```

---

## Hosts文件更新

### Hosts 文件结构

```text
# 用户自己的配置（不受影响）
127.0.0.1       localhost
192.168.1.1     router.local

# === LanLink Managed Begin ===
192.168.1.100   pc-a.local      # LanLink
192.168.1.101   pc-b.local      # LanLink
192.168.1.102   server.local    # LanLink
# === LanLink Managed End ===

# 用户其他配置（不受影响）
192.168.1.50    myserver
```

### 更新操作流程

#### 1. 添加/更新节点

```
节点上线事件
    │
    ↓
┌─────────────────┐
│ 触发回调         │
│ onNodeChange()  │
└─────────────────┘
    │
    ↓
┌─────────────────┐
│ 备份Hosts文件    │
│ hosts → hosts.bak
└─────────────────┘
    │
    ↓
┌─────────────────┐
│ 读取Hosts内容    │
└─────────────────┘
    │
    ↓
┌─────────────────┐
│ 在标记区域查找   │
│ 是否存在该域名   │
└─────────────────┘
    │
┌───┴───┐
│       │
存在    不存在
│       │
│       ↓
│   添加新行:
│   192.168.1.101 pc-b.local # LanLink
│       │
└───────┘
    │
    ↓
更新IP:
192.168.1.101 pc-b.local # LanLink
(如果IP变化)
    │
    ↓
┌─────────────────┐
│ 写回Hosts文件    │
└─────────────────┘
    │
    ↓
完成
```

#### 2. 删除节点

```
节点离线事件
    │
    ↓
┌─────────────────┐
│ 触发回调         │
│ onNodeChange()  │
└─────────────────┘
    │
    ↓
┌─────────────────┐
│ 备份Hosts文件    │
└─────────────────┘
    │
    ↓
┌─────────────────┐
│ 读取Hosts内容    │
└─────────────────┘
    │
    ↓
┌─────────────────┐
│ 在标记区域查找   │
│ 匹配该域名的行   │
└─────────────────┘
    │
    ↓
┌─────────────────┐
│ 删除该行         │
└─────────────────┘
    │
    ↓
┌─────────────────┐
│ 写回Hosts文件    │
└─────────────────┘
    │
    ↓
完成
```

### 安全机制

1. **标记区域隔离**
   - 只在 `Begin` 和 `End` 之间操作
   - 不影响用户手动配置

2. **自动备份**
   - 每次修改前创建 `.bak` 备份
   - 出错可以恢复

3. **原子性**
   - 先写入新内容，再整体替换
   - 避免中途失败导致文件损坏

---

## 优雅退出

### 退出流程

```
用户按 Ctrl+C
    │
    ↓
┌─────────────────┐
│ 捕获信号         │
│ SIGINT/SIGTERM  │
└─────────────────┘
    │
    ↓
┌─────────────────┐
│ 发送离线消息     │
│ {"action":      │
│  "offline"}     │
└─────────────────┘
    │
    ↓
 广播到组播组
    │
    ↓
其他节点接收
    │
    ↓
立即删除该节点
    │
    ↓
┌─────────────────┐
│ 等待消息发送     │
│ (100毫秒)       │
└─────────────────┘
    │
    ↓
┌─────────────────┐
│ 关闭组播连接     │
└─────────────────┘
    │
    ↓
┌─────────────────┐
│ 关闭日志文件     │
└─────────────────┘
    │
    ↓
程序退出
```

### 代码实现

```go
// 监听退出信号
sigChan := make(chan os.Signal, 1)
signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

// 主循环
for {
    select {
    case <-sigChan:
        logger.Info("收到退出信号，正在清理...")
        
        // 发送离线通知
        msg := &network.Message{
            Action:   network.ActionOffline,
            Domain:   domain,
            IP:       localIP,
            DeviceID: deviceID,
            Hostname: cfg.DeviceName,
        }
        client.Send(msg)
        
        // 等待发送完成
        time.Sleep(100 * time.Millisecond)
        
        logger.Info("=== LanLink 已退出 ===")
        return
    }
}
```

### 为什么需要优雅退出？

**对比：**

| 场景 | 非优雅退出 | 优雅退出 |
|------|-----------|---------|
| 直接关闭程序 | 其他节点30秒后才发现离线 | 立即通知其他节点 |
| Hosts清理 | 延迟30秒 | 立即清理 |
| 用户体验 | ⚠️ 可能出现域名解析失败 | ✅ 立即生效 |

---

## 完整交互示例

### 场景：三台设备的完整生命周期

```
设备A (pc-a.local)      设备B (pc-b.local)      设备C (pc-c.local)
     │                        │                        │
     │ T=0s                   │                        │
     ├─> 启动                 │                        │
     ├─> 发送心跳 ────────────>────────────────────────>
     │   (广播)                │                        │
     │                        │                        │
     │                   T=5s │                        │
     │                        ├─> 启动                 │
     │<────────────────────────── 发送心跳             │
     │                        │   (广播)               │
     │                        │                        │
     │ [更新Hosts]             │ [更新Hosts]            │
     │ +pc-b.local            │ +pc-a.local            │
     │                        │                        │
     │ T=10s                  │ T=10s                  │
     ├─> 定时心跳 ────────────>──>                     │
     │                        │                        │
     │                        │                   T=15s│
     │<────────────────────────────────────────────────┤─> 启动
     │                        │<────────────────────────── 发送心跳
     │                        │                        │
     │ [更新Hosts]             │ [更新Hosts]            │ [更新Hosts]
     │ +pc-c.local            │ +pc-c.local            │ +pc-a.local
     │                        │                        │ +pc-b.local
     │                        │                        │
     │ T=20s                  │ T=20s                  │ T=20s
     ├─> 心跳 ───────────────>──>──────────────────────>
     │<────────────────────────── 心跳                 │
     │<────────────────────────────────────────────────┤─ 心跳
     │                        │                        │
     │ 现在三台设备都知道彼此，可以互相访问                    │
     │                        │                        │
     │ T=30s                  │                        │
     │ Ctrl+C                 │                        │
     ├─> 离线通知 ────────────>──>──────────────────────>
     │                        │                        │
     X 退出                   │ [删除Hosts]            │ [删除Hosts]
                              │ -pc-a.local            │ -pc-a.local
                              │                        │
```

---

## 总结

### 核心设计理念

1. **事件驱动**：通过回调机制解耦模块
2. **去中心化**：无需中心服务器，P2P通信
3. **自动化**：无需手动配置，自动发现和更新
4. **可靠性**：心跳+超时机制，自动检测离线
5. **安全性**：隔离操作区域，自动备份

### 关键技术点

| 技术 | 用途 | 实现 |
|------|------|------|
| UDP 组播 | 节点间通信 | 239.255.0.1:9527 |
| 心跳机制 | 保持在线状态 | 每10秒发送 |
| 超时检测 | 发现离线节点 | 30秒无心跳 |
| 回调函数 | 模块解耦 | SetChangeCallback |
| 标记区域 | 隔离用户配置 | Begin/End 标记 |
| 优雅退出 | 立即通知离线 | 信号处理 |

### 数据流向

```
配置文件 → Config → Main
                     │
                     ├→ Logger → 文件/控制台
                     │
                     ├→ Network → 组播消息 → Node → Hosts → 系统文件
                     │            ↑           │
                     │            └───────────┘
                     │           心跳循环
                     │
                     └→ 定时器 → 心跳发送
                              → 离线检测
```

---

**这就是 LanLink 的完整执行逻辑！** 🚀

简单总结就是：
1. 启动时初始化所有模块
2. 通过组播广播自己的信息
3. 接收其他节点的广播并更新 Hosts
4. 定期发送心跳保持在线
5. 定期检测离线节点并清理
6. 退出时通知其他节点

整个过程 **全自动**，用户无需任何操作！

